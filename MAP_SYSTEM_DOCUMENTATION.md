# Map System Technical Documentation

## How the Map System Works

The map system implements a two-tier offline-first caching strategy with automatic refresh that maintains a 3-mile radius "bubble" around the user's current GPS location, covering zoom levels 13-18. When MapPage initializes, it dispatches a MapStarted event to MapBloc, which immediately queries Hive (via OfflineMapRegionRepository) for the most recently synced OfflineMapRegion; if found, it emits MapReady with that region and the current offline status (determined by NetworkChecker.isConnected()), allowing the map to render instantly from cache. If no cached region exists, MapBloc emits MapLoading and triggers OfflineBubbleRefreshRequested, which calls MapRepository.loadRegionForCurrentLocation() with a 4.8 km radius (approximately 3 miles), zoomMin 13, and zoomMax 18. This method first obtains the current GPS position via GeolocationService, computes a bounding box using lat/lon deltas (latitude delta = radiusKm / 111.0, longitude delta accounts for latitude with cos(lat) correction), creates an OfflineMapRegion with a unique timestamped ID, saves a snapshot to Firestore (non-blocking), sets _currentOfflineBubble in the repository, clears old regions and their tiles via OfflineMapCache.clearOutside() (which iterates all Hive tiles, checks if they were in the old region but are outside the new region's bounding box using OfflineMapRegion.containsTile(), and deletes them to keep storage compact), clears the in-memory LRU cache, then executes Phase 1: _primeBubbleTiles() downloads the center tile at zoom 18 plus a 3×3 grid (9 tiles total) around it, checking Hive first and only fetching from MapboxRemoteDataSource if missing and online, immediately persisting each to Hive via OfflineMapCache.putTile() which serializes the MapTile (containing z/x/y coordinates, image bytes, fetchedAt timestamp, and sizeInBytes) to JSON and stores it in a Hive box with key format "z/x/y", enforcing a 500MB cache limit with LRU eviction of oldest tiles when exceeded. Phase 1 completes and returns the region metadata immediately, allowing the UI to render MapReady state and display the map centered on the region's centerLat/centerLon at zoomMax, while Phase 2 runs asynchronously: downloadRegion() computes all tile indices for the region using _computeTileIndices() which iterates zoom levels 13-18, converts the bounding box corners to tile coordinates using _latLonToTile() (Web Mercator: n = 1 << zoom, x = floor((lon + 180) / 360 * n), y = floor((1 - ln(tan(latRad) + sec(latRad)) / π) / 2 * n)), generates all (z, x, y) tuples within those bounds, then downloads each tile sequentially, checking Hive first, fetching from Mapbox if missing, persisting to Hive, updating progress via StreamController<double> which MapBloc listens to via streamRegionStatus(), converting progress events to OfflineBubbleProgressReported events that emit OfflineRegionUpdating states showing a progress overlay on the map. When the user interacts with the map (pan/zoom), MapboxWebController (which embeds Mapbox GL JS v3.4.0 via HtmlElementView, injecting the CSS and JS scripts into the document head, creating a Map instance with transformRequest callback) fires moveend/zoomend events that call _emitCamera(), which reads the current center and zoom via JS interop (getCenter(), getZoom()), creates a MapCameraState, and calls onCameraIdle which updates _currentCamera in MapPage state and dispatches MapCameraMoved to MapBloc, which updates _lastCamera but doesn't reset the map view (didUpdateWidget was fixed to not call setCenter(), allowing free user interaction). Tile fetching follows an offline-first pattern: MapRepository.getTile() first checks OfflineMapCache.getTile() which queries Hive with key "z/x/y", deserializes the JSON to MapTile, and returns it if found; if not in Hive, it checks _liveTilesCache (an in-memory Map<String, MapTile> with max 500 entries, FIFO eviction) for tiles outside the bubble that were fetched during the session; if still missing and online, it fetches from MapboxRemoteDataSource, then calls _isTileInOfflineBubble() which loads the latest region from OfflineMapRegionRepository if _currentOfflineBubble is null, checks if the tile's zoom is within region.zoomMin-zoomMax, and calls region.containsTile(z, x, y) which converts tile coordinates to lat/lon using inverse Web Mercator (lon = x/n * 360 - 180, lat = atan(sinh(π * (1 - 2y/n))) * 180/π) and checks if within the bounding box; if inside the bubble, the tile is persisted to Hive via putTile(), otherwise it's stored only in _liveTilesCache. When offline (NetworkChecker.isOfflineMode() returns true, either naturally or via test override setTestModeOverride(true)), MapboxWebController's _handleTransformRequest() intercepts all tile requests via the transformRequest callback, calls _shouldBlockUrl() which parses tile coordinates from the URL regex r'/(\d{1,2})/(\d+)/(\d+)', checks if the zoom is outside the bubble's range or if containsTile() returns false, and if so returns an empty data:, URI causing Mapbox to render a blank/gray tile, ensuring users can only see cached tiles when offline. The auto-refresh mechanism runs via a 5-minute Timer in MapBloc (_startOrRestartRefreshTimer()) plus GPS movement threshold checks (_hasMovedMoreThanThreshold() calculates distance using GeolocationService.calculateDistance() with Haversine formula, threshold is 804.672 meters / ~0.5 miles); when either triggers, _startNewBubble() calls loadRegionForCurrentLocation() which computes a new bubble, clears old tiles via clearOutside(), primes new center tiles, and starts background download, maintaining a "sliding bubble" that follows the user. The UI appearance: MapPage displays a full-screen MapboxMapView (interactive by default, can be disabled via interactive: false for previews) with a Stack overlay containing a MapStatusCard in the top-left showing region name, offline/online icon (cloud_off in orange when offline, cloud_queue in blue when online), and either a progress bar with percentage during Phase 2 download or "Offline bubble active" / "Live + offline bubble" text when ready; top-right contains two cards: an offline test toggle (Switch with cloud icon, toggles NetworkChecker test mode override) and a layers button (IconButton with layers icon) that toggles _showCacheOverlay. When the overlay is enabled, CachedRegionOverlayPainter draws a circle representing the 3-mile cached region: it converts the region's centerLat/centerLon to screen coordinates using _latLonToScreen() which implements Web Mercator projection (converts camera center and target point to tile coordinates, calculates pixel offsets using 256px tile size, offsets from screen center), calculates radius in pixels via _calculateRadiusPixels() (converts 4.8 km to lat delta, computes north point, projects both to screen, measures distance), draws a semi-transparent fill circle (15% opacity, blue when online, orange when offline), a 2px border circle (solid blue/orange), a 6px center marker (filled circle with border), and a text label above the circle ("Cached Region - 3 mile radius" or "OFFLINE - Cached Region (3 mi)") with shadow for readability; the overlay repaints when camera zoom/lat/lon changes (shouldRepaint checks zoom difference and 0.0001 degree threshold). The cache page (MapCachePage) displays a non-interactive MapboxMapView preview (interactive: false, zoom 13, centered on region) with a simplified RegionBoundsPainter drawing a rectangular overlay (15% margin, semi-transparent blue fill with 2px border), a center marker (12px white-bordered blue circle), and an info overlay at the bottom showing center coordinates; below the preview, _buildRegionInfo() shows a table with region name, center coordinates, bounding box (NE/SW corners), zoom range (13-18), tile count (downloaded/total), status, and last synced timestamp. The entire system is designed for instant first-frame rendering (Phase 1), non-blocking background downloads (Phase 2), graceful offline degradation (blank tiles outside bubble), automatic refresh as users move, and bounded disk usage through bubble size limits and LRU eviction, with all tile operations logged via Logger for debugging.

