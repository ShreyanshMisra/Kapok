# Complete Map System Architecture and Offline Feature Explanation

## System Overview

The map system is a Flutter web application implementing an offline-first map caching architecture using Mapbox GL JS for rendering, Hive for persistent tile storage, Firebase Firestore for cross-device metadata syncing, and a BLoC pattern for state management. The system maintains a dynamic 3-mile radius "bubble" around the user's GPS location, automatically caching map tiles at zoom levels 13-18, with a two-phase download strategy that prioritizes instant first-frame rendering followed by background completion, and implements a two-tier caching system (persistent Hive storage for offline tiles plus in-memory LRU cache for live exploration tiles) that ensures smooth panning while keeping disk usage bounded.

## File Architecture and Responsibilities

### UI Layer (Presentation)

**`app/lib/features/map/pages/map_page.dart`** - The main interactive map screen that orchestrates the entire user experience. It's a StatefulWidget that maintains local UI state (\_testOfflineMode toggle, \_showCacheOverlay visibility, \_currentCamera tracking, \_mapController reference, \_overlayCircle pre-computed coordinates), listens to MapBloc state changes via BlocConsumer, and renders different UI based on state (MapLoading shows spinner, MapReady shows interactive map with overlays, OfflineRegionUpdating shows progress bar, MapError shows error message). When initialized, it dispatches MapStarted event via post-frame callback, builds a full-screen Stack containing MapboxMapView (extending behind transparent AppBar), MapStatusCard in top-left showing region name and offline status, test controls in top-right (offline toggle switch and layers button), and optional CachedRegionOverlayPainter overlay that draws a circle representing the cached region using pre-computed screen coordinates from Mapbox's native project() method. The \_updateOverlayCircle() method is called whenever camera changes (via onCameraIdle callback) or overlay is toggled, which uses \_mapController.projectLatLonToScreen() to convert region center lat/lon to pixel coordinates, calculates radius by projecting a point 4.8km north and measuring pixel distance, then stores OverlayCircle(center: Offset, radius: double) in state for the painter to use, eliminating projection errors.

**`app/lib/features/map/pages/map_cache_page.dart`** - A read-only cache management screen displaying cached region metadata and a non-interactive map preview. It loads regions from OfflineMapRegionRepository on init, displays a 300px-height MapboxMapView with interactive: false (disabling all user gestures), shows region information table (name, center coordinates, bounding box, zoom range, tile counts, status, last synced timestamp), and includes a simplified RegionBoundsPainter that draws a rectangular overlay representing the cached area. The preview map is centered on the region's bounding box center with zoom level 13.5 to frame the entire 3-mile bubble.

**`app/lib/features/map/widgets/mapbox_map_view.dart`** - A platform-aware wrapper widget that abstracts web vs mobile rendering. On web, it creates a MapboxWebController instance, sets initial camera, offline bubble, and interaction settings, exposes onControllerReady callback to allow parent widgets to access the controller for projection calculations, and builds an HtmlElementView that hosts the Mapbox GL JS canvas. The widget accepts parameters for initialLatitude/longitude/zoom, offlineBubble region, isOfflineMode flag, onCameraIdle callback, onMapReady callback, and interactive boolean (defaults to true, set to false for previews). The didUpdateWidget method updates bubble and offline mode without resetting camera position (critical fix that allows free user interaction), and dispose() properly cleans up the web controller.

### State Management (BLoC Pattern)

**`app/lib/features/map/bloc/map_bloc.dart`** - The central state coordinator using flutter_bloc that manages the entire map lifecycle. It extends Bloc<MapEvent, MapState>, maintains internal state (\_activeRegion, \_lastCamera, \_lastRefresh timestamp, \_refreshTimer for 5-minute intervals, \_progressSubscription for download progress), and handles five event types: MapStarted (loads latest cached region from repository, emits MapReady if found or MapLoading if not, starts refresh timer, triggers OfflineBubbleRefreshRequested if no cache exists), MapCameraMoved (updates \_lastCamera, re-emits MapReady with new camera state), OfflineBubbleRefreshRequested (checks if force flag is set or if 5-minute interval passed and GPS movement exceeded 804.672 meters threshold via \_hasMovedMoreThanThreshold() which uses GeolocationService.calculateDistance() with Haversine formula, then calls \_startNewBubble() which loads new region and starts progress subscription), OfflineBubbleProgressReported (emits OfflineRegionUpdating state with progress 0.0-1.0, transitions to MapReady when progress >= 1.0), and OfflineBubbleDownloadCompleted (updates \_activeRegion and emits MapReady). The \_startNewBubble() method calls mapRepository.loadRegionForCurrentLocation() with 4.8km radius, zoomMin 13, zoomMax 18, stores the returned region in \_activeRegion, records \_lastRefresh timestamp, emits MapReady immediately (Phase 1 complete), then subscribes to streamRegionStatus() progress stream which dispatches OfflineBubbleProgressReported events as Phase 2 downloads tiles in background.

**`app/lib/features/map/bloc/map_event.dart`** - Defines five event classes extending Equatable: MapStarted (no parameters, fired on page init), MapCameraMoved (contains MapCameraState with lat/lon/zoom, fired when user stops panning/zooming), OfflineBubbleRefreshRequested (has force: bool flag, fired by timer or manual refresh), OfflineBubbleProgressReported (has regionId: String and progress: double 0.0-1.0, fired by repository progress stream), and OfflineBubbleDownloadCompleted (has OfflineMapRegion, fired when download finishes).

**`app/lib/features/map/bloc/map_state.dart`** - Defines four state classes extending Equatable: MapLoading (initial state, shows spinner), MapReady (contains region: OfflineMapRegion, isOfflineMode: bool, lastCamera: MapCameraState?, shows interactive map), OfflineRegionUpdating (contains region, progress: double, isOfflineMode, shows map with progress overlay), and MapError (contains message: String, shows error UI).

**`app/lib/features/map/models/map_camera_state.dart`** - Simple data class storing latitude, longitude, and zoom level, used for camera position tracking and state persistence.

### Data Layer (Repository Pattern)

**`app/lib/data/repositories/map_repository.dart`** - The core business logic layer implementing MapRepository interface, coordinating between data sources and providing offline-first tile fetching. MapRepositoryImpl maintains \_currentOfflineBubble reference (cached for fast lookups), \_liveTilesCache in-memory Map<String, MapTile> with max 500 entries using FIFO eviction for tiles outside the bubble, and \_progressControllers Map<String, StreamController<double>> for broadcasting download progress per region. The getTile(z, x, y) method implements offline-first pattern: first checks OfflineMapCache.getTile() which queries Hive box with key "z/x/y", deserializes JSON to MapTile, returns if found; if not in Hive, checks \_liveTilesCache for session tiles; if still missing and NetworkChecker.isConnected() returns true, fetches from MapboxRemoteDataSource.fetchTile(), then calls \_isTileInOfflineBubble() which loads latest region from OfflineMapRegionRepository if \_currentOfflineBubble is null, checks if tile zoom is within region.zoomMin-zoomMax range, and calls region.containsTile(z, x, y) which converts tile coordinates to lat/lon using inverse Web Mercator (lon = x/n _ 360 - 180, lat = atan(sinh(π _ (1 - 2y/n))) _ 180/π) and checks if within bounding box; if inside bubble, persists to Hive via OfflineMapCache.putTile(), otherwise stores only in \_liveTilesCache. The loadRegionForCurrentLocation() method is the heart of the system: it calls GeolocationService.getCurrentPosition() to get GPS coordinates, computes bounding box using latDelta = radiusKm / 111.0 and lonDelta = radiusKm / (111.0 _ cos(lat)) to account for longitude compression at different latitudes, creates OfflineMapRegion with unique timestamped ID, saves MapSnapshot to Firestore via FirebaseMapSnapshotSource (non-blocking, for cross-device sync), sets \_currentOfflineBubble = region, loads all existing regions from OfflineMapRegionRepository, calls OfflineMapCache.clearOutside(newRegion, oldRegion) for each old region (which iterates all Hive tiles, checks if they were in old region but are outside new region using containsTile(), deletes them to free space), deletes old region metadata, clears \_liveTilesCache, then executes Phase 1: \_primeBubbleTiles() downloads center tile at zoomMax (18) plus 3×3 grid (9 tiles total), checking Hive first and only fetching if missing and online, immediately persisting each via putTile(), returns primedCount, then immediately returns region metadata; Phase 2 runs asynchronously: downloadRegion() computes all tile indices using \_computeTileIndices() which iterates zoom levels 13-18, converts bounding box corners to tile coordinates via \_latLonToTile() (Web Mercator: n = 1 << zoom, x = floor((lon + 180) / 360 _ n), y = floor((1 - ln(tan(latRad) + sec(latRad)) / π) / 2 _ n)), generates all (z, x, y) tuples, downloads sequentially with progress updates via StreamController, and the streamRegionStatus() method returns the StreamController's stream for a given regionId.

**`app/lib/data/repositories/offline_map_region_repository.dart`** - Manages OfflineMapRegion metadata persistence in a separate Hive box named 'offline_map_regions'. It provides methods: initialize() opens Hive box, saveRegion() serializes OfflineMapRegion to JSON and stores with key = region.id, getRegion() retrieves and deserializes, getAllRegions() returns all regions, getLatestRegion() sorts by lastSyncedAt descending and returns most recent, deleteRegion() removes by ID, clearAll() empties box, deleteAllRegionsExcept() keeps only specified region (used for sliding bubble). All operations are wrapped in try-catch with CacheException handling.

### Data Sources (Storage and Remote APIs)

**`app/lib/data/sources/offline_map_cache.dart`** - The persistent tile storage layer using Hive (NoSQL database) with a box named 'offline_map_tiles'. It maintains \_currentCacheSizeBytes counter and enforces maxCacheSizeBytes limit (default 500MB). Methods: initialize() opens Hive box and calculates current size by iterating all tiles and summing sizeInBytes, getTile(z, x, y) constructs key "z/x/y", queries Hive.get(key), deserializes JSON to MapTile using MapTile.fromJson(), returns tile or null, putTile(tile) checks if adding tile would exceed limit, calls \_evictOldTiles() if needed (which loads all tiles, sorts by fetchedAt timestamp ascending, deletes oldest until space freed), serializes tile to JSON via MapTile.toJson(), stores in Hive with key = tile.key, increments \_currentCacheSizeBytes, clearOutside(newRegion, oldRegion) iterates all Hive keys, parses z/x/y from key string, checks if tile was in old region (using oldRegion.containsTile()) but is NOT in new region (using !newRegion.containsTile()), deletes those tiles and decrements cache size, clearRegion(region) deletes all tiles within a region's bounding box and zoom range, clearAll() empties entire box. The \_calculateCacheSize() method iterates all tiles and sums their sizeInBytes for accurate tracking.

**`app/lib/data/sources/mapbox_remote_data_source.dart`** - HTTP client for fetching tiles from Mapbox Styles API. It constructs URLs in format `https://api.mapbox.com/styles/v1/{styleId}/tiles/{z}/{x}/{y}@{ratio}x?access_token={token}`, uses http.get() to fetch, returns MapTile with response.bodyBytes as data, format 'png256', and fetchedAt timestamp. The fetchTiles() method supports batch downloading with onProgress callback.

**`app/lib/data/sources/firebase_map_snapshot_source.dart`** - Firestore integration for cross-device map view syncing. It stores MapSnapshot objects (containing center coordinates, bounding box, zoom range, lastUpdatedAt timestamp) in 'mapSnapshots' collection with document ID = userId/teamId. Methods: saveSnapshot() writes to Firestore, getSnapshot() reads, getSnapshotStream() returns real-time stream for automatic updates, deleteSnapshot() removes. This allows other devices to see where the user last viewed the map and pre-warm their caches.

### Models (Data Structures)

**`app/lib/data/models/offline_map_region_model.dart`** - The core data model representing a cached geographic region. It contains: id (unique string, typically timestamped), centerLat/centerLon (GPS coordinates of bubble center), zoomMin/zoomMax (13-18 typically), northEastLat/northEastLon/southWestLat/southWestLon (bounding box corners), name (human-readable like "Current Location Region"), lastSyncedAt (DateTime), totalTiles/downloadedTiles (counts for progress), status ('pending', 'downloading', 'completed', 'failed'). The containsTile(z, x, y) method is critical: it converts tile coordinates to lat/lon using inverse Web Mercator projection (n = 1 << z, lonDeg = x/n _ 360 - 180, calculates sinh manually as (exp(val) - exp(-val)) / 2 where val = π _ (1 - 2y/n), latRad = atan(sinhVal), latDeg = latRad \* 180/π), then checks if latDeg is within southWestLat to northEastLat and lonDeg is within southWestLon to northEastLon. The model is JSON-serializable for Hive storage.

**`app/lib/data/models/map_tile_model.dart`** - Represents a single map tile with zoom, x, y coordinates, raw Uint8List data (PNG bytes for raster tiles), format string ('png', 'jpg', 'mvt'), fetchedAt timestamp, and computed sizeInBytes getter. The key getter returns "z/x/y" string for Hive storage. Methods: fromJson() deserializes (converts data list to Uint8List), toJson() serializes (converts Uint8List to list), copyWith() creates modified copies.

### Web Rendering Layer

**`app/lib/features/map/web/mapbox_web_controller.dart`** - The JavaScript interop layer that embeds Mapbox GL JS v3.4.0 into Flutter web via HtmlElementView. It uses dart:html, dart:js, and dart:ui_web for DOM manipulation and JS interop. The controller maintains \_container (html.DivElement), \_mapInstance (JavaScript Map object), \_scriptsInjected flag, and exposes properties: initialCamera, offlineBubble, isOfflineMode, interactive (getter/setter that calls \_updateInteractionSettings() to enable/disable drag, zoom, keyboard, touch handlers), onCameraIdle callback, onMapReady callback. The \_ensureRendered() method injects Mapbox CSS and JS scripts into document.head (only once per page load), sets mapboxgl.accessToken, creates Map instance with container, style URI, initial center/zoom, and transformRequest callback that intercepts all tile requests. The \_handleTransformRequest() method receives (url, resourceType) from Mapbox, calls \_shouldBlockUrl() which parses tile coordinates from URL regex r'/(\d{1,2})/(\d+)/(\d+)', checks if isOfflineMode is true and tile is outside bubble (zoom outside range or !offlineBubble.containsTile()), returns empty 'data:,' URI if should block (causing Mapbox to render blank tile), otherwise returns original URL. The \_emitCamera() method is registered as listener for 'moveend' and 'zoomend' events, reads current center via map.getCenter() and zoom via map.getZoom(), creates MapCameraState, calls onCameraIdle callback. The projectLatLonToScreen(lat, lon) method calls map.project([lng, lat]) (Mapbox expects [lng, lat] array, not object), reads x/y from returned point object, returns Offset(x, y) for overlay rendering. The \_updateInteractionSettings() method accesses map.handlers object and enables/disables dragPan, scrollZoom, boxZoom, doubleClickZoom, keyboard, touchZoomRotate handlers based on interactive flag. The \_registerViewFactory() creates HtmlElementView factory that returns a div with absolute positioning and 100% width/height.

**`app/lib/features/map/web/mapbox_web_controller_stub.dart`** - Fallback implementation for non-web platforms (mobile), returns empty widgets and no-op methods.

### Core Services

**`app/lib/core/services/network_checker.dart`** - Network connectivity detection using connectivity_plus package. It checks ConnectivityResult, attempts InternetAddress.lookup('google.com') to verify actual internet access (skipped on web, assumes connectivity means internet), provides getNetworkQuality() that measures response time, getConnectionType() (WiFi, Mobile, Ethernet, etc.), and has test mode override via setTestModeOverride(bool?) for simulating offline mode during development.

**`app/lib/core/services/geolocation_service.dart`** - GPS location services using geolocator package. It handles permission requests, checks if location services are enabled, provides getCurrentPosition() with high accuracy and 10-second timeout, getLastKnownPosition() for cached location, calculateDistance() using Haversine formula (a = sin²(Δlat/2) + cos(lat1) _ cos(lat2) _ sin²(Δlon/2), c = 2 _ atan2(√a, √(1-a)), distance = R _ c where R = 6371000 meters), and location stream for continuous updates.

## How the Offline Feature Works

The offline system implements a "sliding bubble" strategy where a 3-mile radius region around the user's current GPS location is automatically cached at zoom levels 13-18, with automatic refresh every 5 minutes or when the user moves more than 0.5 miles. When MapPage initializes, it dispatches MapStarted to MapBloc, which immediately queries OfflineMapRegionRepository.getLatestRegion() to load the most recently synced region from Hive; if found, it emits MapReady with that region and current offline status (from NetworkChecker.isOfflineMode()), allowing instant map rendering from cache. If no cached region exists, MapBloc emits MapLoading and triggers OfflineBubbleRefreshRequested, which calls MapRepository.loadRegionForCurrentLocation() with 4.8km radius, zoomMin 13, zoomMax 18. This method first obtains current GPS position via GeolocationService.getCurrentPosition(), computes bounding box using latDelta = 4.8 / 111.0 and lonDelta = 4.8 / (111.0 \* cos(lat)) to account for longitude compression, creates OfflineMapRegion with unique timestamped ID, saves MapSnapshot to Firestore (non-blocking, for cross-device sync), sets \_currentOfflineBubble in repository, loads all existing regions, calls OfflineMapCache.clearOutside() for each old region (which iterates all Hive tiles, checks if they were in old region but are now outside new region using containsTile(), deletes them to keep storage compact), deletes old region metadata, clears in-memory LRU cache, then executes Phase 1: \_primeBubbleTiles() downloads center tile at zoom 18 plus 3×3 grid (9 tiles), checking Hive first, fetching from Mapbox if missing and online, immediately persisting to Hive via putTile(), returns primedCount, then immediately returns region metadata so UI can render MapReady state instantly. Phase 2 runs asynchronously: downloadRegion() computes all tile indices for the region using \_computeTileIndices() (iterates zoom 13-18, converts bounding box to tile coordinates, generates all z/x/y tuples), downloads each tile sequentially, checks Hive first, fetches from Mapbox if missing, persists to Hive, updates progress via StreamController which MapBloc listens to via streamRegionStatus(), converting progress events to OfflineBubbleProgressReported that emit OfflineRegionUpdating states showing progress overlay. Tile fetching follows offline-first pattern: MapRepository.getTile() first checks OfflineMapCache.getTile() (queries Hive with key "z/x/y", deserializes JSON), then checks \_liveTilesCache in-memory Map (max 500 entries, FIFO eviction), then if online fetches from MapboxRemoteDataSource, then calls \_isTileInOfflineBubble() which checks if tile zoom is within region.zoomMin-zoomMax and calls region.containsTile() (converts tile coords to lat/lon, checks bounding box); if inside bubble, persists to Hive via putTile(), otherwise stores only in \_liveTilesCache. When offline (NetworkChecker.isOfflineMode() returns true, either naturally or via test override), MapboxWebController's \_handleTransformRequest() intercepts all tile requests via transformRequest callback, calls \_shouldBlockUrl() which parses tile coordinates from URL regex, checks if zoom is outside bubble range or containsTile() returns false, returns empty 'data:,' URI if should block (causing Mapbox to render blank/gray tile), ensuring users can only see cached tiles when offline. The auto-refresh mechanism runs via 5-minute Timer in MapBloc plus GPS movement threshold (804.672 meters) check; when either triggers, \_startNewBubble() calls loadRegionForCurrentLocation(), computes new bubble, clears old tiles via clearOutside(), primes new center tiles, starts background download, maintaining a "sliding bubble" that follows the user. The overlay system uses Mapbox's native map.project() method via JavaScript interop: \_updateOverlayCircle() calls \_mapController.projectLatLonToScreen() to convert region center to pixel coordinates, calculates radius by projecting point 4.8km north and measuring pixel distance, stores OverlayCircle(center: Offset, radius: double) in state, and CachedRegionOverlayPainter draws circle using these pre-computed coordinates, eliminating projection errors and accounting for camera bearing/pitch automatically. The entire system is designed for instant first-frame rendering (Phase 1), non-blocking background downloads (Phase 2), graceful offline degradation (blank tiles outside bubble), automatic refresh as users move, and bounded disk usage through bubble size limits, LRU eviction, and clearOutside() purging of tiles outside the active bubble.
